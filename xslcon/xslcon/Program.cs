/******************************************************
 * This tool is designed to convert the XML generated by
 * Visual Studio into a Markdown-formatted document
 * for the REST API reference.
 * It is set up to extract the details from all members 
 * belonging to UI.ChronozoomSVC and magically convert it 
 * into Markdown. 
 * 
 * v.1 by William French
 ******************************************************/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.XPath;
using System.Xml.Xsl;
using System.IO;
using System.Text.RegularExpressions;
using System.Diagnostics;

namespace xslcon
{
    class MDConverter
    {
        static string baseClass = "M:UI.ChronozoomSVC.";
        static Regex nameRgx = new Regex(@"M:UI\.ChronozoomSVC\.\w*");
        static string[] nameList = null;

        static void Main(string[] args)
        {
            // xmlpath refers to the documentation XML generated by Visual Studio.
            // In the Chronozoom project it is found here: \ChronoZoom\Source\Chronozoom.UI\bin
            string xmlpath = @"C:\Users\v-wfren\Documents\GitHub\ChronoZoom\Source\Chronozoom.UI\bin\UI.XML";

            try
            {
                nameList = getNames(xmlpath);
            }
            catch (Exception e)
            {
                Console.Write("An exception occurred: " + e.Message);
            }

            if (nameList != null)
            {
                //string toc = makeToc(nameList);
                getMember(baseClass + "Get", xmlpath);
            }
        }

        // A first attempt at XSL transformation.
        static void convertMe(string fullPath)
        {
            XPathDocument myXPathDoc = new XPathDocument(fullPath);
            XslCompiledTransform myXslTrans = new XslCompiledTransform();
            //myXslTrans.Load(@"C:\Users\v-wfren\Documents\Visual Studio 2012\Projects\xslcon\xslcon\xslt\myStyleSheet.xslt");
            myXslTrans.Load(@"C:\Users\v-wfren\Documents\Visual Studio 2012\Projects\xslcon\xslcon\xslt\apihtml.xslt");
            XmlTextWriter myWriter = new XmlTextWriter(@"C:\Users\v-wfren\Documents\Visual Studio 2012\Projects\xslcon\xslcon\output\result.html",null);
            myXslTrans.Transform(myXPathDoc, null, myWriter);
        }

        // Uses XSLT to get the names and output as array.
        static string[] getNames(string path)
        {
            // Load the XSL stuff.
            XPathDocument myXPathDoc = new XPathDocument(path);
            XslCompiledTransform myXslTrans = new XslCompiledTransform();

            // Load the XSL from its embedded resource.
            using (StringReader srt = new StringReader(xslcon.Properties.Resources.api_names))
            {
                using (XmlReader xrt = XmlReader.Create(srt))
                {
                    myXslTrans.Load(xrt);
                }
            }

            // Or load the XSL manually.
            //myXslTrans.Load(@"C:\Users\v-wfren\Documents\GitHub\docteam\xslcon\xslcon\xslt\api-names.xslt");

            // Run the transform.
            StringWriter sw = new StringWriter();
            using (sw)
            {
                myXslTrans.Transform(myXPathDoc, null, sw);
            }

            // Use the regex to extract the members we want.
            MatchCollection mc = nameRgx.Matches(sw.ToString());
            
            // Trim the base class name and stack it.
            Stack<string> nameStack = new Stack<string>();
            foreach (Match m in mc)
            {
                string n = m.Value.Replace(baseClass, "");
                nameStack.Push(n);
            }

            string[] nameArray = nameStack.ToArray();
            Array.Reverse(nameArray);
            return nameArray;
        }

        // Take a member name, get the data.
        static string[] getMember(string name, string path)
        {
            // Todo: Make this work so you can get a member by name.
            // Load the XSL stuff.
            XPathDocument myXPathDoc = new XPathDocument(path);
            XslCompiledTransform myXslTrans = new XslCompiledTransform();

            // Load the XSL from its embedded resource.
            using (StringReader srt = new StringReader(xslcon.Properties.Resources.api_member))
            {
                using (XmlReader xrt = XmlReader.Create(srt))
                {
                    myXslTrans.Load(xrt);
                }
            }

            // Run the transform.
            StringWriter sw = new StringWriter();
            using (sw)
            {
                myXslTrans.Transform(myXPathDoc, null, sw);
            }
            
            string[] ret = new string[] { };
            return ret;
        }

        // On second thought why don't we just do this using XSL?
        //static string makeMember(string[] input)
        //{
        //    StringBuilder sb = new StringBuilder();

        //    // Todo: add code to take the array and spit out a string in Markdown.
        //    return "0";
        //}

        static string makeToc(string[] input)
        {
            StringBuilder sb = new StringBuilder();

            for (int i = 0; i < input.Length; i++)
            {
                string item = input[i].ToString();
                string tocLine = "- [" + item + "](#" + item.ToLower() + ")";
                sb.AppendLine(tocLine);
            }

            return sb.ToString();
        }

    }
}

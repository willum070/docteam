/******************************************************
 * This tool is designed to convert the XML generated by
 * Visual Studio into a Markdown-formatted document
 * for the REST API reference.
 * It is set up to extract the details from all members 
 * belonging to UI.ChronozoomSVC and magically convert it 
 * into Markdown. 
 * 
 * v.2 by William French
 ******************************************************/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.Linq;
using System.Xml.XPath;
using System.Xml.Xsl;
using System.IO;
using System.Text.RegularExpressions;
using System.Diagnostics;

namespace xslcon
{
    class MDConverter
    {
        static string baseClass = "M:UI.ChronozoomSVC.";
        static Regex nameRgx = new Regex(@"M:UI\.ChronozoomSVC\.\w*");
        static string[] nameList = null;

        static void Main(string[] args)
        {
            // xmlpath refers to the documentation XML generated by Visual Studio.
            // In the Chronozoom project it is found here: \ChronoZoom\Source\Chronozoom.UI\bin
            string xmlpath = @"C:\Users\v-wfren\Documents\GitHub\ChronoZoom\Source\Chronozoom.UI\bin\UI.XML";

            //getMember(baseClass + "Get", xmlpath);
            getNames(xmlpath);
        }

        // A first attempt at XSL transformation.
        static void convertMe(string fullPath)
        {
            XPathDocument myXPathDoc = new XPathDocument(fullPath);
            XslCompiledTransform myXslTrans = new XslCompiledTransform();
            //myXslTrans.Load(@"C:\Users\v-wfren\Documents\Visual Studio 2012\Projects\xslcon\xslcon\xslt\myStyleSheet.xslt");
            myXslTrans.Load(@"C:\Users\v-wfren\Documents\Visual Studio 2012\Projects\xslcon\xslcon\xslt\apihtml.xslt");
            XmlTextWriter myWriter = new XmlTextWriter(@"C:\Users\v-wfren\Documents\Visual Studio 2012\Projects\xslcon\xslcon\output\result.html",null);
            myXslTrans.Transform(myXPathDoc, null, myWriter);
        }

        // Uses XSLT to get the names and output as array.
        static string[] getNames(string path)
        {
            // Load the XML document.
            XDocument doc = XDocument.Load(path);

            //XElement e = doc.Element("doc")
            //                .Element("members")
            //                .Element("member");
            //Console.WriteLine("Customers has attributes? {0}", e.HasAttributes);
            //Console.WriteLine(e.Attribute("name"));

            Stack<string> nameStack = new Stack<string>();
            //foreach (Match m in mc)
            //{
            //    string n = m.Value.Replace(baseClass, "");
            //    nameStack.Push(n);
            //}

            var query =
                from member in doc.Descendants("member")
                select
                    new XElement("member",
                                    member.Attribute("name"),
                                    getName((string)member.Attribute("name")));
            foreach (var result in query)
            {
                //Console.WriteLine(result);
                string n = result.Value.Replace(baseClass, "");
                nameStack.Push(n);
            }

            string[] nameArray = nameStack.ToArray();
            Array.Reverse(nameArray);

            //string[] nameArray = new string[] { };
            return nameArray;
        }

        static string getName(string name)
        {
            Regex regex = new Regex(@"M:UI\.ChronozoomSVC\.\w*");
            //return new XElement("isCorrectClass", regex.IsMatch(name));
            if (regex.IsMatch(name))
            {
                string n = name.Replace(baseClass, "");
                return name;
            }
            else
            {
                return "0";
            }            
        }

        // Take a member name, get the data.
        static string[] getMember(string name, string path)
        {
            // Todo: Make this work so you can get a member by name.
            // Load the XSL stuff.
            XPathDocument myXPathDoc = new XPathDocument(path);
            XslCompiledTransform myXslTrans = new XslCompiledTransform();

            // Load the XSL from its embedded resource.
            using (StringReader srt = new StringReader(xslcon.Properties.Resources.api_member))
            {
                using (XmlReader xrt = XmlReader.Create(srt))
                {
                    myXslTrans.Load(xrt);
                }
            }

            // Run the transform.
            StringWriter sw = new StringWriter();
            using (sw)
            {
                myXslTrans.Transform(myXPathDoc, null, sw);
            }
            
            string[] ret = new string[] { };
            return ret;
        }

        // On second thought why don't we just do this using XSL?
        //static string makeMember(string[] input)
        //{
        //    StringBuilder sb = new StringBuilder();

        //    // Todo: add code to take the array and spit out a string in Markdown.
        //    return "0";
        //}

        static string makeToc(string[] input)
        {
            StringBuilder sb = new StringBuilder();

            for (int i = 0; i < input.Length; i++)
            {
                string item = input[i].ToString();
                string tocLine = "- [" + item + "](#" + item.ToLower() + ")";
                sb.AppendLine(tocLine);
            }

            return sb.ToString();
        }

    }
}

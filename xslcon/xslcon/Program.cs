/******************************************************
 * This tool is designed to convert the XML generated by
 * Visual Studio into a Markdown-formatted document
 * for quick API reference.
 * It is set up to extract the details from all members 
 * belonging to whatever, and magically convert it 
 * into Markdown. 
 * 
 * version 0.5 by William French
 ******************************************************/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Configuration;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.Linq;
using System.Xml.XPath;
using System.Xml.Xsl;
using System.IO;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Collections.Specialized;

namespace xslcon
{
    class MDConverter
    {
        /* Prefixes, regexes and paths are defined in settings.
         * The prefixes are configurable since they could change.
         * The regexes are also configurable and should match
         * their corresponding member prefix string. */
        static string memberClass = Properties.Settings.Default.MemberClass;
        static Regex memberRgx = new Regex(Properties.Settings.Default.MemberRgx);

        static StringCollection paramBase = Properties.Settings.Default.ParamBase;

        static string entityTypeClass = Properties.Settings.Default.EntityTypeClass;
        static Regex entityTypeRgx = new Regex(Properties.Settings.Default.EntityTypeRgx);

        static string entityPropClass = Properties.Settings.Default.EntityPropClass;

        // These are the paths to the VS doc XML files we are going to process.
        static string memberPath = Properties.Settings.Default.MemberPath;
        static string entityPath = Properties.Settings.Default.EntityPath;

        // The top portion of the document.
        static string topMatter = Properties.Settings.Default.TopMatter;

        static void Main(string[] args)
        {
            generateMarkdown();            
        }

        // Run everything and output a file.
        static void generateMarkdown()
        {
            if(File.Exists(memberPath))
            {
                makeDoc(memberPath);
            }
        }

        // Get all of the members and return MarkDown.
        static string getMembers(string path)
        {
            // Load the XML document.
            XDocument doc = XDocument.Load(path);

            StringBuilder sbToc = new StringBuilder();
            StringBuilder sbContent = new StringBuilder();

            // Get all of the members.
            var qMembers =
                from member in doc.Descendants("member")
                where (memberRgx.IsMatch(member.Attribute("name").Value))
                select
                    member;

            // We're using count to make each link unique.
            int count = 0;
            sbToc.AppendLine("## Contents ##");

            // Add each member to the doc.
            foreach (var member in qMembers)
            {
                count += 1;
                string name = cleanStringParams(member.Attribute("name").Value, memberClass, paramBase);
                string id = (cleanString(member.Attribute("name").Value, memberClass) + "_" + count).ToLower();

                // Add a TOC entry.
                sbToc.AppendLine("- [" + name + "](#" + id + ")");

                sbContent.AppendLine("<a id=\"" + id + "\"></a>");
                sbContent.AppendLine("## " + name + " ##");
                sbContent.AppendLine(" ");
                sbContent.AppendLine(member.XPathSelectElement("summary").Value.Trim());
                sbContent.AppendLine(" ");

                if (member.XPathSelectElement("returns") != null)
                {
                    sbContent.AppendLine("**Returns**");
                    sbContent.AppendLine(member.XPathSelectElement("returns").Value.Trim());
                    sbContent.AppendLine(" ");
                }

                if (member.XPathSelectElement("example") != null)
                {
                    sbContent.AppendLine("**Example**");
                    string ex = member.XPathSelectElement("example").Value;
                    ex = cleanExample(ex);
                    sbContent.AppendLine(ex);
                    sbContent.AppendLine(" ");
                }

                var qParams =
                    from p in member.Descendants("param")
                    select
                        p;

                if (qParams.Count() != 0)
                {
                    sbContent.AppendLine("**Parameters**");
                    sbContent.AppendLine(" ");
                    sbContent.AppendLine("|Parameter|Value|");
                    sbContent.AppendLine("|:--------|:----|");

                    foreach (var param in qParams)
                    {
                        sbContent.AppendLine("|" + param.FirstAttribute.Value + "|" + param.Value + "|");
                    }
                    sbContent.AppendLine(" ");
                }
                else
                {
                    sbContent.AppendLine("**Parameters**");
                    sbContent.AppendLine("None.");
                    sbContent.AppendLine(" ");
                }

                if (member.XPathSelectElement("remarks") != null)
                {
                    sbContent.AppendLine("**Remarks**");
                    sbContent.AppendLine(cleanExample(member.XPathSelectElement("remarks").Value.Trim()));
                    sbContent.AppendLine(" ");
                }

                sbContent.AppendLine(" ");
                sbContent.AppendLine("----------");
                sbContent.AppendLine(" ");
            }

            sbToc.AppendLine(" ");
            sbContent.Insert(0, sbToc.ToString());
            return sbContent.ToString();
        }

        // Get all of the entities and return MarkDown.
        //static string getEntities(string path)
        //{
        //    // Load the XML document.
        //    XDocument doc = XDocument.Load(path);

        //    StringBuilder sb = new StringBuilder();

        //    // Get all of the entities.
        //    var qEntityTypes =
        //        from member in doc.Descendants("member")
        //        where (entityTypeRgx.IsMatch(member.Attribute("name").Value))
        //        select
        //            member;

        //    foreach (var member in qEntityTypes)
        //    {
        //        string nameString = cleanString(member.Attribute("name").Value, entityTypeClass);

        //        //@"P:Chronozoom\.Entities\.Bookmark\.\w*"
        //        Regex entityPropRgx = new Regex(@"P:Chronozoom\.Entities\." + nameString + @"\.\w*");

        //        var qEntityProps =
        //            from pmember in doc.Descendants("member")
        //            where (entityPropRgx.IsMatch(pmember.Attribute("name").Value))
        //            select
        //                pmember;

        //        sb.AppendLine("### " + nameString + " ###");
        //        sb.AppendLine(" ");
        //        sb.AppendLine(member.Element("summary").Value.Trim());
        //        sb.AppendLine(" ");

        //        var qParams =
        //            from p in member.Descendants("param")
        //            select
        //            p;

        //        if (qParams.Count() != 0)
        //        {
        //            sb.AppendLine("|Enum|Value|");
        //            sb.AppendLine("|:--------|:----|");

        //            foreach (var param in qParams)
        //            {
        //                sb.AppendLine("|" + cleanString(param.FirstAttribute.Value, entityPropClass + nameString) + "|" + param.Value + "|");
        //            }
        //        }

        //        if (qEntityProps.Count() != 0)
        //        {
        //            sb.AppendLine("|Property|Value|");
        //            sb.AppendLine("|:-------|:----|");


        //            foreach (var prop in qEntityProps)
        //            {
        //                // P:Chronozoom.Entities.[member].[prop]
        //                string propName = cleanString(prop.FirstAttribute.Value, entityPropClass + nameString + ".");
        //                sb.AppendLine("|" + propName + "|" + prop.Value.Trim() + "|");
        //            }
        //        }

        //        //sb.AppendLine(" ");
        //        //sb.AppendLine("[top](#chronozoom-rest-api-reference)");
        //        sb.AppendLine(" ");
        //        sb.AppendLine("----------");
        //        sb.AppendLine(" ");
        //    }

        //    return sb.ToString();
        //}

        // Uses Linq to get the names and output as array.
        
        //static string makeToc(string path, Regex rgx, string repl)
        //{
        //    // Todo: Now navigation is broken. Re-do this so that we are inserting JQuery to autogenerate a TOC. 
        //    // instead of this function.

        //    // Load the XML document.
        //    XDocument doc = XDocument.Load(path);

        //    StringBuilder sb = new StringBuilder();

        //    // Get all of the names.
        //    var query =
        //        from member in doc.Descendants("member")
        //        select
        //            new XElement("member",
        //                            member.Attribute("name").Value);

            
        //    // Filter and clean the strings.
        //    foreach (var member in query)
        //    {
        //        if (rgx.IsMatch(member.Value))
        //        {
        //            string nDisp = cleanStringParams(member.Value, repl, paramBase);
        //            string nLink = cleanString(member.Value, repl);
        //            string tocLine = "- [" + nDisp + "](#" + nLink.ToLower() + ")";
        //            sb.AppendLine(tocLine);
        //        }
        //    }

        //    return sb.ToString();
        //}

        // Clean up strings, return only member name.
        static string cleanString(string n, string repl)
        {
            n = n.Replace(repl, "");
            int pStart = n.IndexOf("(");

            if (pStart > 0)
            {
                n = n.Remove(pStart);
                return n;
            }
            else
            {
                return n;
            }
        }

        // Clean up strings + params, return method signature.
        static string cleanStringParams(string n, string repl, StringCollection paramBase)
        {
            n = n.Replace(repl, "");
            int pStart = n.IndexOf("(");
            int pEnd = n.IndexOf(")");
            int len = pEnd - pStart;
            string theParams = "()";

            if (len > 0)
            {
                theParams = n.Substring(pStart, len + 1);
                foreach (string s in paramBase)
                {
                    theParams = theParams.Replace(s, "");
                }
                theParams = theParams.Replace(",", ", ");
            }

            if (pStart > 0)
            {
                n = n.Remove(pStart);
            }

            n = n + theParams;

            return n;
        }

        // Clean up example code (extra spaces since they are in CDATA in the source).
        private static string cleanExample(string ex)
        {
            string aLine, fullExample = "";
            StringReader sr = new StringReader(ex);
            while (true)
            {
                aLine = sr.ReadLine();
                if (aLine != null)
                    fullExample += aLine.Replace("            ", "    ") + "\n";
                else
                    return fullExample;
            }

            return fullExample;
        }

        static void makeDoc(string path)
        {
            StringBuilder sb = new StringBuilder();

            // Add the top part of the doc.
            //using (StreamReader sr = new StreamReader(topMatter))
            //{
            //    String line = sr.ReadToEnd();
            //    sb.AppendLine(line);
            //}

            // Get the member names and add the TOC.
            sb.AppendLine("# HomeOS.Hub.Common.DataStore.IStream #");
            //string mtoc = makeToc(memberPath, memberRgx, memberClass);
            //sb.AppendLine(mtoc);

            // Get the members and build the reference portion.
            string members = getMembers(memberPath);
            sb.AppendLine(members);

            using (StreamWriter outfile = new StreamWriter(Properties.Settings.Default.OutFile))
            {
                outfile.Write(sb.ToString());
            }
        }
    }
}
